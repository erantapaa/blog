<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Spanning Tree</title>
  <meta name="description" content="Layout run failed ._.
">

  <!-- syntax highlighter -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://maurizzzio.github.io/static/graphs/tree/spanning-tree.html">
  <link rel="alternate" type="application/rss+xml" title="Mauricio Poppe" href="http://maurizzzio.github.io/feed.xml" />

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mauricio Poppe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

<!--       <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a>
          
        
          
          <a class="page-link" href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a>
          
        
          
          <a class="page-link" href="/static/graphs/components.html">Components</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/derivative.html">Derivative</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/divisor-function.html">Divisor Function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a>
          
        
          
          <a class="page-link" href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/tree/index.html">Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/integral.html">Integral</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/introduction.html">Introduction</a>
          
        
          
          <a class="page-link" href="/static/graphs/introduction.html">Introduction</a>
          
        
          
        
          
          <a class="page-link" href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/primality-test.html">Primality Test</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/quaternions.html">Quaternions</a>
          
        
          
          <a class="page-link" href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a>
          
        
          
          <a class="page-link" href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a>
          
        
          
          <a class="page-link" href="/static/graphs/topological-sorting.html">Topological sorting</a>
          
        
          
          <a class="page-link" href="/static/graphs/traversal.html">Traversal</a>
          
        
      </div>
 -->
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="static-page-sidebar">
        <ul><li><a href="/index.html"></a><ul><li>static<ul><li>computer-graphics<ul><li>math<ul><li><a href="/static/computer-graphics/math/quaternions.html">Quaternions</a><ul></ul></li></ul></li></ul></li><li>graphs<ul><li><a href="/static/graphs/introduction.html">Introduction</a><ul></ul></li><li><a href="/static/graphs/traversal.html">Traversal</a><ul></ul></li><li><a href="/static/graphs/topological-sorting.html">Topological sorting</a><ul></ul></li><li><a href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a><ul></ul></li><li><a href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a><ul></ul></li><li><a href="/static/graphs/components.html">Components</a><ul></ul></li><li><a href="/static/graphs/tree/index.html">Tree</a><ul><li><a href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a><ul></ul></li></ul></li><li><a href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a><ul></ul></li><li>special<ul><li><a href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a><ul></ul></li><li><a href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a><ul></ul></li></ul></li></ul></li><li>math<ul><li>calculus<ul><li><a href="/static/math/calculus/introduction.html">Introduction</a><ul></ul></li><li><a href="/static/math/calculus/derivative.html">Derivative</a><ul></ul></li><li><a href="/static/math/calculus/integral.html">Integral</a><ul></ul></li><li><a href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a><ul></ul></li></ul></li><li>number-theory<ul><li><a href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a><ul></ul></li><li><a href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a><ul></ul></li><li><a href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a><ul></ul></li><li><a href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a><ul></ul></li><li><a href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a><ul></ul></li><li><a href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a><ul></ul></li><li><a href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a><ul></ul></li><li><a href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a><ul></ul></li><li><a href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a><ul></ul></li><li><a href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a><ul></ul></li><li><a href="/static/math/number-theory/primality-test.html">Primality Test</a><ul></ul></li><li><a href="/static/math/number-theory/divisor-function.html">Divisor Function</a><ul></ul></li><li><a href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a><ul></ul></li></ul></li><li>numeral-systems<ul><li><a href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a><ul></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
      </div>

      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Spanning Tree</h1>
  </header>

  <article class="post-content">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script src="//maurizzzio.github.io/greuler/scripts/lib/cola.v3.js"></script>

<script src="//maurizzzio.github.io/greuler/greuler.js"></script>

<p>If a connected graph $G$ of order $n$ has no cycles then of course $G$ is a tree, let’s suppose that $G$ contains cycles, let $e_1$ be an edge lying on a cycle of $G$ we know that since $e_1$ is part of cycle it’s not a bridge which means that $G - e_1$ is connected, if $G - e_1$ contains cycles then let $e_2$ be an edge lying on a cycle of $G - e_1$, $e_2$ is not a bridge and therefore $G - e_1 - e_2$ is still connected. Eventually we arrive to the set $X = {e_1, e_2, \ldots, e_k}$ of edges such that $G - X$ doesn’t contain cycles (i.e. it’s a tree) which has the same vertex set of $G$ ($V(G) = V(G - X)$).</p>

<p>Let $T = G - X$ be a tree with the same vertex set of $G$</p>

<ul>
  <li>$T$ is a spanning subgraph of $G$, since $T$ is also a tree it’s called a <strong>spanning tree</strong> of $G$</li>
</ul>

<div id="figure-spanning-tree"></div>

<h2 id="minimum-spanning-tree">Minimum spanning tree</h2>

<p>Let $G$ be a <em>connected weighted graph</em> where the weight of an edge $e \in E(G)$ is denoted by $w(e)$, for each subgraph $H$ of $G$ the weight of the subgraph $W$ is the sum of the weights of its edges</p>

<script type="math/tex; mode=display">w(H) = \sum_{e \in E(H)} w(e)</script>

<p>We are looking for a spanning tree of $G$ whose weight is minimum among all spanning trees of $G$, such a spanning tree is called <strong>minimum spanning tree</strong> (shortened as MST)</p>

<div id="figure-minimum-spanning-tree"></div>

<script type="math/tex; mode=display">G = (V, E) \\
V = \{0, 1, 2, 3, 4\} \\
E = \{\{0, 1\}, \{0, 2\}, \{0, 3\}, \{0, 4\}, \{1, 2\}, \{1, 3\}, \{1, 4\}, \{2, 3\}, \{3, 4\}\} \\
w(e) = \{1, 4, 4, 5, 3, 7, 5, 6, 2\}</script>

<ul>
  <li>the MST is unique if the weights of all the edges are different</li>
  <li>the maximum spanning tree is the tree whose weight is maximum among all spanning trees, it can be computed using the algorithm below by using the edges with the maximum weight instead of the ones with the minimum weight</li>
</ul>

<h3 id="kruskals-algorithm">Kruskal’s algorithm</h3>

<p>For a connected weighted graph $G$ a spanning tree is constructed as follows</p>

<ul>
  <li>for the first edge $e_1$ we select any edge of $G$ of minimum weight</li>
  <li>for the second edge $e_2$ we select any remaining edge of $G$ of minimum weight</li>
  <li>for the third edge $e_3$ we select any remaining edge of $G$ of minimum weight <em>that does not produce a cycle with the previously selected edges</em></li>
  <li>we continue in this manner until a spanning tree is produced</li>
</ul>

<p>Let’s apply it to the weighted graph above, sorting the edges in nondecreasing order we have:</p>

<script type="math/tex; mode=display">w(e) = {1, 2, 3, 4, 4, 5, 5, 6, 7}</script>

<ul>
  <li>The edge with the minimum cost is $e_1 = v_0v_1$ with $w(e_1) = 1$, $e_1$ is part of the MST</li>
  <li>The edge with the minimum cost is now $e_9 = v_3v_4$ with $w(e_9) = 2$, $e_2$ is part of the MST</li>
  <li>The next edge is $e_5 = v_1v_2$ with $w(e_5) = 3$, since it does not form a cycle with the previously selected edges it’s part of the MST</li>
  <li>The next edge is $e_2 = v_0v_2$ with $w(e_2) = 4$, this one forms a cycle with the following path $v_0,v_1,v_2$ so it’s not part of the MST</li>
  <li>The next edge is $e_3 = v_0v_3$ with $w(e_3) = 4$, since it does not form a cucle with the previously selected edges it’s part of the MST</li>
  <li>No need to do more iterations since the set is already a spanning tree</li>
</ul>

<pre><code class="language-cpp">struct edge {
  int u, v, weight;
  edge(int _u, int _v, int _w) {
    u = _u; v = _v; weight = _w;
  }
  // custom sort
  bool operator&lt;(const edge &amp;other) const {
    return weight &lt; other.weight;
  }
};

vector&lt;int&gt; tree, size;

void initialize_sets(int n) {
  tree.resize(n);
  size.resize(n);
  for (int i = 0; i &lt; n; i += 1) {
    tree[i] = i;
    size[i] = 1;
  }
}

int find_set(int element) {
  if (element != tree[element]) {
    tree[element] = find_set(tree[element]);
  }
  return tree[element];
}

void set_union(int x, int y) {
  int rx, ry;
  rx = find_set(x);
  ry = find_set(y);
  if (rx == ry) {
    return;
  }
  if (rx &gt; ry) {
    size[rx] += size[ry];
    tree[ry] = rx;
  } else {
    size[ry] += size[rx];
    tree[rx] = ry;
  }
}

/**
 * An implementation of Kruskal's algorithm which computes
 * the minimum spanning tree of a graph `G`
 *
 * Time complexity: O(m log m)
 * Space complexity: O(m)
 *
 * @param {vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;} g The adjacency list representation
 * of a graph `G`, each entry `g_{ij}` holds a pair which represents an edge
 * (vertex, weight) which tells that there's an edge from `i` to `vertex`
 * with weight `weight`
 * @return {int} The weight of the MST
 */
int kruskal(vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; &amp;g) {
  int n = g.size();

  vector&lt;edge&gt; edges;
  for (int i = 0; i &lt; n; i += 1) {
    for (int j = 0; j &lt; g[i].size(); j += 1) {
      int v = g[i][j].first;
      int weight = g[i][j].second;
      edges.push_back(edge(i, v, weight));
    }
  }

  initialize_sets(n);

  sort(edges.begin(), edges.end());

  int total = 0;
  for (int i = 0; i &lt; edges.size(); i += 1) {
    int u = find_set(edges[i].u);
    int v = find_set(edges[i].v);
    if (u != v) {
      set_union(u, v);
      total += edges[i].weight;
    }
  }

  return total;
}

</code></pre>

<h3 id="prims-algorithm">Prim’s algorithm</h3>

<p>For a connected weighted graph $G$ a spanning tree is constructed as follows</p>

<ul>
  <li>for an arbitrary vertex $u$ and edge of minimum weight $e_1$ incident to $u$ is chosen as the first edge of the MST</li>
  <li>for subsequent edges $e_2, e_3, \ldots, e_{n - 1}$ we select an edge of minimum weight among those edges having <strong>exactly one of its vertices incident with an edge already selected</strong></li>
</ul>

<h4 id="prim-in-dense-graphs">Prim in dense graphs</h4>

<p>Let’s say we’re given the following problem</p>

<blockquote>
  <p>given $n$ points in a plane find the skeleton of minimum weight that connects them all</p>
</blockquote>

<p>This problem can be modeled as a graph of order $n$ where each vertex is connected to every other vertex by an edge of weight equal to the euclidean distance between the vertices therefore $m \approx n^2$</p>

<p>Implementation strategies:</p>

<ul>
  <li>we need a data structure that keeps track of a single edge per vertex (space: $O(n)$ and is able to tell the one with the minimum weight (doing $O(n)$ queries), since $m \approx n^2$ we visit each vertex finding an edge with minimum cost (each query will take $O(n)$ for an overall $O(n^2)$ time complexity)</li>
  <li>after an arbitrary vertex $u$ has been chosen all the vertices incident to $u$ will update their minimum edge weight</li>
</ul>

<pre><code class="language-cpp">/**
 * An implementation of Prim's algorithm which computes
 * the minimum spanning tree of a dense graph `G`
 *
 * Time complexity: O(n^2)
 * Space complexity: O(n)
 *
 * @param {vector&lt;vector&lt;int&gt; &gt;} g The adjacency matrix of `G`, each entry `a_{ij}`
 * holds the weight of the edge connecting vertex `i` and vertex `j`, if this number
 * is &lt;= 0 then `i` and `j` are not adjacent
 * @return {int} The weight of the MST
 */
int prim(vector&lt;vector&lt;int&gt; &gt; &amp;g) {
  int n = g.size();
  int INF = 1e9;
  int total = 0;

  vector&lt;bool&gt; visited(n, false);
  // holds the weight of the edge of minimum weight incident
  // to the vertex `i`
  vector&lt;int&gt; min_weight_edge(n, INF);
  // (optional) holds the index of a vertex adjacent to the
  // vertex `i` in the MST, note that the size of the MST is
  // n - 1 so the first vertex won't store the mentioned index
  vector&lt;int&gt; neighbor_selected(n, -1);

  // pick the first node as the "arbitrary" node
  min_weight_edge[0] = 0;

  for (int i = 0; i &lt; n; i += 1) {
    int v = -1;
    for (int j = 0; j &lt; n; j += 1) {
      // find the vertices which haven't been visited yet
      // among them find a vertex with the minimum edge weight
      if (!visited[j] &amp;&amp; (v == -1 ||
          min_weight_edge[j] &lt; min_weight_edge[v])) {
        v = j;
      }
    }

    visited[v] = true;
    total += min_weight_edge[v];

    // update the minimum edge weight of all the vertices
    // adjacent to `v`
    for (int to = 0; to &lt; n; to += 1) {
      if (g[v][to] &gt; 0 &amp;&amp;
          g[v][to] &lt; min_weight_edge[to]) {
        min_weight_edge[to] = g[v][to];
        // update the candidate neighbor of the vertex `to` to
        // be `v` since it's connected with an edge
        // of minimum weight among all the adjacent vertices to `to`
        neighbor_selected[to] = v;
      }
    }
  }

  return total;
}

</code></pre>

<h4 id="prim-in-sparse-graphs">Prim in sparse graphs</h4>

<p>Implementation strategies:</p>

<ul>
  <li>we need a data structure that keeps track of a single edge per vertex (space: $O(n)$ and is able to tell the one with the minimum weight (doing $O(n)$ queries), since $m \approx n$ we analyze each edge finding the one with minimum weight $O(n)$ times, we can use a red-black tree (each operation takes $O(log\;n)$ for an overall $O(m\;log \;n)$ time complexity)</li>
  <li>after an arbitrary vertex $u$ has been chosen all the vertices incident to $u$ will update their minimum edge weight</li>
  <li>the red-black tree will hold $n - 1$ entries at max (one entry per vertex), each iteration a vertex will be removed from the red-black tree</li>
  <li>there will be exactly $n$ iterations if the graph is connected</li>
</ul>

<pre><code class="language-cpp">/**
 * C++11
 *
 * An implementation of Prim's algorithm which computes
 * the minimum spanning tree of a sparse graph `G` of order `n` and size `m`
 *
 * Time complexity: O(m log n)
 * Space complexity: O(n)
 *
 * @param {vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;} g The adjacency list representation
 * of a graph `G`, each entry `g_{ij}` holds a pair which represents an edge
 * (vertex, weight) which tells that there's an edge from `i` to `vertex`
 * with weight `weight`
 * @return {int} The weight of the MST or a negative number if the graph
 * wasn't connected
 */
int prim(vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; &amp;g) {
  int n = g.size();
  int total = 0;

  vector&lt;bool&gt; visited(n, false);
  // holds the weight of the edge of minimum weight incident
  // to the vertex `i`
  vector&lt;int&gt; min_cost(n, INF);
  // (optional) holds the index of a vertex adjacent to the
  // vertex `i` in the MST, note that the size of the MST is
  // n - 1 so the first vertex won't store the mentioned index
  vector&lt;int&gt; neighbor(n, -1);

  // the first node is the "arbitrary" node for the sake of the implementation
  min_cost[0] = 0;

  // (min weight, vertex)
  set&lt;pair&lt;int, int&gt; &gt; q;
  q.insert({0, 0});

  while (!q.empty()) {
    int v = q.begin()-&gt;second;

    // the vertex `v` belongs to the MST and is adjacent
    // to the vertex `neighbor[v]` with and edge
    // of weight `weight`
    total += q.begin()-&gt;first;

    q.erase(q.begin());

    visited[v] = true;

    for (int i = 0; i &lt; g[v].size(); i += 1) {
      pair&lt;int, int&gt; &amp;next = g[v][i];

      // note that in the graph the first element is the neighbor vertex
      // but in the set the first element is the edge weight
      int to = next.first;
      int weight = next.second;

      if (!visited[to] &amp;&amp; weight &lt; min_cost[to]) {
        q.erase({ min_cost[to], to });
        min_cost[to] = weight;
        neighbor[to] = v;
        q.insert({ min_cost[to], to });
      }
    }
  }
  // check that every vertex has a min cost edge associated
  for (int i = 0; i &lt; n; i += 1) {
    if (min_cost[i] == INF) {
      return -1;
    }
  }
  return total;
}

</code></pre>

<h2 id="number-of-spanning-trees-in-a-graph">Number of spanning trees in a graph</h2>

<p>Let $G$ be a graph with $V(G) = {v_1, v_2, \ldots, v_n}$, let $A = [a_{ij}]$ be the adjacency matrix of $G$ and let $C = [c_{ij}]$ be a $n \times n$ matrix where</p>

<script type="math/tex; mode=display">% <![CDATA[
c_{ij} = \begin{cases}
deg\;v_i & \text{if $i = j$} \\
-a_{ij} & \text{if $i \neq j$} \\
\end{cases} %]]></script>

<p>Then the number of spanning trees of $G$ is the value of any cofactor of $C$</p>

<p>The matrix of cofactors a $n \times n$ matrix $C = [c_{ij}]$ where</p>

<script type="math/tex; mode=display">c_{ij} = (-1)^{i + j} \cdot det(M_{ij})</script>

<p>$det(M_{ij})$ indicates the determinant of the $(n - 1) \times (n - 1)$ submatrix of $M$ obtained by removing the $i$-th row and the $j$-th column</p>

<pre><code class="language-cpp">/**
 * Given a square matrix M of size (n x n) this method
 * computes the a matrix of size (n - 1) x (n - 1) by eliminating
 * the elements belonging to the `row` row of M and the `col`
 * column of M
 *
 * @param {vector&lt;vector&lt;int&gt; &gt; } m The square matrix
 * @param {int} row The row to be ignored
 * @param {int} col The column to be ignored
 * @return {vector&lt;vector&lt;int&gt; &gt;} the value of the determinant
 */
vector&lt;vector&lt;int&gt; &gt; minor(vector&lt;vector&lt;int&gt; &gt; m, int row, int col) {
  int n = m.size();
  vector&lt;vector&lt;int&gt; &gt; t(n - 1, vector&lt;int&gt;(n - 1));

  int trow = 0;
  for (int i = 0; i &lt; n; i += 1) {
    if (i == row) {
      continue;
    }
    int tcol = 0;
    for (int j = 0; j &lt; n; j += 1) {
      if (j == col) {
        continue;
      }
      t[trow][tcol] = m[i][j];
      tcol += 1;
    }
    trow += 1;
  }
  return t;
}

/**
 * Computes the determinant of an square matrix
 *
 * @param {vector&lt;vector&lt;int&gt; &gt; } m The square matrix
 * @return {int} the value of the determinant
 */
int determinant(vector&lt;vector&lt;int&gt; &gt; m) {
  int n = m.size();

  if (n == 1) {
    return m[0][0];
  }
  if (n == 2) {
    return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }

  int result = 0;
  for (int col = 0; col &lt; n; col += 1) {
    vector&lt;vector&lt;int&gt; &gt; t = minor(m, 0, col);
    result += m[0][col] * pow(-1, col) * determinant(t);
  }
  return result;
}

/**
 * Computes the number of spanning trees in an undirected graph `G`
 *
 * @param &lt;vector&lt;vector&lt;int&gt; &gt; &gt; g The adjacency matrix of `G`
 * @return {int} The number of spanning trees
 */
int number_of_spanning_trees(vector&lt;vector&lt;int&gt; &gt; &amp;g) {
  int n = g.size();
  vector&lt;vector&lt;int&gt; &gt; t = g;
  for (int i = 0; i &lt; n; i += 1) {
    // -a_{ij} for elements that are not in the main diagonal
    int degree = 0;
    for (int j = 0; j &lt; n; j += 1) {
      if (i != j) {
        t[i][j] *= -1;
        if (t[i][j]) {
          degree += 1;
        }
      }
    }

    // deg v_i for t[i][i]
    t[i][i] = degree;
  }

  // compute the (0,0) cofactor
  // c_{0, 0} = (-1)^{0 + 0} * determinant((0, 0) minor)
  //          = determinant((0, 0) minor)
  return determinant(minor(t, 0, 0));
}

</code></pre>

<h3 id="number-of-spanning-trees-in-a-complete-graph-kn">Number of spanning trees in a complete graph $K_n$</h3>

<p>Computing the number of spanning trees of a graph $G = K_n$ where $V(G) = {v_1, v_2, \ldots, v_n}$ is the same as computing the number of distinct trees with vertex set ${v_1, v_2, \ldots, v_n}$, the formula is called the <strong>Caley Tree Formula</strong></p>

<blockquote>
  <p>The number of spanning trees of order $n$ with a specific vertex set is $n^{n - 2}$</p>
</blockquote>

<p>TODO:</p>

<ul>
  <li>find the relationship between prim’s mst and dijsktra’s</li>
  <li>second minimum spanning tree, hint: MST + LCA http://codeforces.com/blog/entry/9570</li>
</ul>

<script>
(function () {
  d3.json('/js/graph/data/spanning-tree.json', function (err, data) {
    if (err) { throw err }
    greuler({
      target: '#figure-spanning-tree',
      data: data
    }).update()
  })

  d3.json('/js/graph/data/minimum-spanning-tree.json', function (err, data) {
    if (err) { throw err }
    greuler({
      target: '#figure-minimum-spanning-tree',
      data: data
    }).update()
  })
})();
</script>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Mauricio Poppe</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Mauricio Poppe</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/maurizzzio">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">maurizzzio</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/iMauricio">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">iMauricio</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Layout run failed ._.
</p>
      </div>
    </div>

  </div>

  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: 'none',
    tex2jax: {
      // http://docs.mathjax.org/en/latest/options/tex2jax.html
      inlineMath: [['$','$']],
      displayMath: [['$$','$$']]
      // processEnvironments: false
    },
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      Macros: {
        edge: '\\mathrel{-}',
        notedge: '\\not\\edge'
      }
    },
    'HTML-CSS': {
      imageFont: null
    }
  });
</script>

<script type="text/javascript">
/*
 * MathJax eqn preview for a tags
 *
 * Copyright (c) 2015 Mauricio Poppe
 * Licensed under the MIT license.
 */

(function () {
  var $container = $('.post-content');
  var $tooltip = $('<div />').addClass('mathjax-tooltip');
  $container.append($tooltip);

  function onMouseOver(ev) {
    var a = ev.currentTarget;
    var $number = $(a.hash);
    var $root = $number.closest('.MathJax_Display');
    var bounds = $(a).offset();
    var containerBounds = $container.offset();

    $tooltip.stop(true, true);
    $tooltip.empty();
    $tooltip.append($root.clone());
    $tooltip.css({
      top: bounds.top - containerBounds.top - $tooltip.height() - 5,
      left: -1
    });
    $tooltip.addClass('active');
  }

  function onMouseOut(a) {
    $tooltip.removeClass('active');
  }

  MathJax.Hub.Queue(function () {
    $container.on('mouseover', 'a[href*="mjx-eqn-"]', onMouseOver);
    $container.on('mouseout', 'a[href*="mjx-eqn-"]', onMouseOut);
  });

})();
</script>

</footer>


  </body>

</html>
