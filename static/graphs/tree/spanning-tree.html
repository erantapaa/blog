<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Spanning Tree</title>
  <meta name="description" content="Layout run failed ._.
">

  <!-- syntax highlighter -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://maurizzzio.github.io//static/graphs/tree/spanning-tree.html">
  <link rel="alternate" type="application/rss+xml" title="Mauricio Poppe" href="http://maurizzzio.github.io//feed.xml" />

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mauricio Poppe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

<!--       <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/combining-transformations.html">Combining transformations</a>
          
        
          
          <a class="page-link" href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a>
          
        
          
          <a class="page-link" href="/static/graphs/components.html">Components</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/derivative.html">Derivative</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/divisor-function.html">Divisor Function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a>
          
        
          
          <a class="page-link" href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/tree/">Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/integral.html">Integral</a>
          
        
          
          <a class="page-link" href="/static/graphs/introduction.html">Introduction</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/introduction.html">Introduction</a>
          
        
          
        
          
          <a class="page-link" href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/orthographic-projection.html">Orthographic projection</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/perspective-projection.html">Perspective projection</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/primality-test.html">Primality Test</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/opengl/projection-matrix.html">Projection matrix</a>
          
        
          
          <a class="page-link" href="/static/math/geometry/projective-geometry.html">Projective Geometry</a>
          
        
          
          <a class="page-link" href="/static/math/numeral-systems/quaternions.html">Quaternions</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/rotation/quaternions.html">Quaternions</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/fundamentals/ray-tracing.html">Ray tracing</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/fundamentals/rendering.html">Rendering</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/resources.html">Resources</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/rotation.html">Rotations</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/scale.html">Scale</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/shearing.html">Shearing</a>
          
        
          
          <a class="page-link" href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/space-coordinates.html">Space coordinates</a>
          
        
          
          <a class="page-link" href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a>
          
        
          
          <a class="page-link" href="/static/graphs/topological-sorting.html">Topological sorting</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/translation.html">Translation</a>
          
        
          
          <a class="page-link" href="/static/graphs/traversal.html">Traversal</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/opengl/view-matrix.html">View matrix</a>
          
        
      </div>
 -->
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="static-page-sidebar">
        <ul><li><li><ul><li>static<ul><li>computer-graphics<ul><li><a href="/static/computer-graphics/resources.html">Resources</a></li><li>fundamentals<ul><li><a href="/static/computer-graphics/fundamentals/rendering.html">Rendering</a></li><li><a href="/static/computer-graphics/fundamentals/ray-tracing.html">Ray tracing</a></li></ul></li><li>math<ul><li><a href="/static/computer-graphics/math/space-coordinates.html">Space coordinates</a></li><li><a href="/static/computer-graphics/math/scale.html">Scale</a></li><li><a href="/static/computer-graphics/math/shearing.html">Shearing</a></li><li><a href="/static/computer-graphics/math/rotation.html">Rotations</a></li><li><a href="/static/computer-graphics/math/translation.html">Translation</a></li><li><a href="/static/computer-graphics/math/orthographic-projection.html">Orthographic projection</a></li><li><a href="/static/computer-graphics/math/perspective-projection.html">Perspective projection</a></li><li><a href="/static/computer-graphics/math/combining-transformations.html">Combining transformations</a></li><li>rotation<ul><li><a href="/static/computer-graphics/math/rotation/quaternions.html">Quaternions</a></li></ul></li></ul></li><li>opengl<ul><li><a href="/static/computer-graphics/opengl/view-matrix.html">View matrix</a></li><li><a href="/static/computer-graphics/opengl/projection-matrix.html">Projection matrix</a></li></ul></li></ul></li><li>graphs<ul><li><a href="/static/graphs/introduction.html">Introduction</a></li><li><a href="/static/graphs/traversal.html">Traversal</a></li><li><a href="/static/graphs/topological-sorting.html">Topological sorting</a></li><li><a href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a></li><li><a href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a></li><li><a href="/static/graphs/components.html">Components</a></li><li><a href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a></li><li>special<ul><li><a href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a></li><li><a href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a></li></ul></li><li>tree<ul><li><a href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a></li></ul></li></ul></li><li>math<ul><li>calculus<ul><li><a href="/static/math/calculus/introduction.html">Introduction</a></li><li><a href="/static/math/calculus/derivative.html">Derivative</a></li><li><a href="/static/math/calculus/integral.html">Integral</a></li><li><a href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a></li></ul></li><li>geometry<ul><li><a href="/static/math/geometry/projective-geometry.html">Projective Geometry</a></li></ul></li><li>number-theory<ul><li><a href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a></li><li><a href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a></li><li><a href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a></li><li><a href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a></li><li><a href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a></li><li><a href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a></li><li><a href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a></li><li><a href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a></li><li><a href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a></li><li><a href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a></li><li><a href="/static/math/number-theory/primality-test.html">Primality Test</a></li><li><a href="/static/math/number-theory/divisor-function.html">Divisor Function</a></li><li><a href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a></li></ul></li><li>numeral-systems<ul><li><a href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a></li><li><a href="/static/math/numeral-systems/quaternions.html">Quaternions</a></li></ul></li></ul></li></ul></li></ul></li></li></ul>
      </div>

      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Spanning Tree</h1>
  </header>

  <article class="post-content">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script src="//maurizzzio.github.io/greuler/scripts/lib/cola.v3.js"></script>

<script src="//maurizzzio.github.io/greuler/greuler.js"></script>

<p>If a connected graph $G$ of order $n$ has no cycles then of course $G$ is a tree, let’s suppose that $G$ contains cycles, let $e_1$ be an edge lying on a cycle of $G$ we know that since $e_1$ is part of cycle it’s not a bridge which means that $G - e_1$ is connected, if $G - e_1$ contains cycles then let $e_2$ be an edge lying on a cycle of $G - e_1$, $e_2$ is not a bridge and therefore $G - e_1 - e_2$ is still connected. Eventually we arrive to the set $X = {e_1, e_2, \ldots, e_k}$ of edges such that $G - X$ doesn’t contain cycles (i.e. it’s a tree) which has the same vertex set of $G$ ($V(G) = V(G - X)$).</p>

<p>Let $T = G - X$ be a tree with the same vertex set of $G$</p>

<ul>
  <li>$T$ is a spanning subgraph of $G$, since $T$ is also a tree it’s called a <strong>spanning tree</strong> of $G$</li>
</ul>

<div id="figure-spanning-tree"></div>

<h2 id="minimum-spanning-tree">Minimum spanning tree</h2>

<p>Let $G$ be a <em>connected weighted graph</em> where the weight of an edge $e \in E(G)$ is denoted by $w(e)$, for each subgraph $H$ of $G$ the weight of the subgraph $W$ is the sum of the weights of its edges</p>

<script type="math/tex; mode=display">w(H) = \sum_{e \in E(H)} w(e)</script>

<p>We are looking for a spanning tree of $G$ whose weight is minimum among all spanning trees of $G$, such a spanning tree is called <strong>minimum spanning tree</strong> (shortened as MST)</p>

<div id="figure-minimum-spanning-tree"></div>

<script type="math/tex; mode=display">G = (V, E) \\
V = \{0, 1, 2, 3, 4\} \\
E = \{\{0, 1\}, \{0, 2\}, \{0, 3\}, \{0, 4\}, \{1, 2\}, \{1, 3\}, \{1, 4\}, \{2, 3\}, \{3, 4\}\} \\
w(e) = \{1, 4, 4, 5, 3, 7, 5, 6, 2\}</script>

<ul>
  <li>the MST is unique if the weights of all the edges are different</li>
  <li>the maximum spanning tree is the tree whose weight is maximum among all spanning trees, it can be computed using the algorithm below by using the edges with the maximum weight instead of the ones with the minimum weight</li>
</ul>

<h3 id="kruskals-algorithm">Kruskal’s algorithm</h3>

<p>For a connected weighted graph $G$ a spanning tree is constructed as follows</p>

<ul>
  <li>for the first edge $e_1$ we select any edge of $G$ of minimum weight</li>
  <li>for the second edge $e_2$ we select any remaining edge of $G$ of minimum weight</li>
  <li>for the third edge $e_3$ we select any remaining edge of $G$ of minimum weight <em>that does not produce a cycle with the previously selected edges</em></li>
  <li>we continue in this manner until a spanning tree is produced</li>
</ul>

<p>Let’s apply it to the weighted graph above, sorting the edges in nondecreasing order we have:</p>

<script type="math/tex; mode=display">w(e) = {1, 2, 3, 4, 4, 5, 5, 6, 7}</script>

<ul>
  <li>The edge with the minimum cost is $e_1 = v_0v_1$ with $w(e_1) = 1$, $e_1$ is part of the MST</li>
  <li>The edge with the minimum cost is now $e_9 = v_3v_4$ with $w(e_9) = 2$, $e_2$ is part of the MST</li>
  <li>The next edge is $e_5 = v_1v_2$ with $w(e_5) = 3$, since it does not form a cycle with the previously selected edges it’s part of the MST</li>
  <li>The next edge is $e_2 = v_0v_2$ with $w(e_2) = 4$, this one forms a cycle with the following path $v_0,v_1,v_2$ so it’s not part of the MST</li>
  <li>The next edge is $e_3 = v_0v_3$ with $w(e_3) = 4$, since it does not form a cucle with the previously selected edges it’s part of the MST</li>
  <li>No need to do more iterations since the set is already a spanning tree</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">edge</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
  <span class="n">edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_w</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_u</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_v</span><span class="p">;</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_w</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// custom sort
</span>  <span class="n">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">edge</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">initialize_sets</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">tree</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">size</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">find_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">!=</span> <span class="n">tree</span><span class="p">[</span><span class="n">element</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">element</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">element</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_union</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">;</span>
  <span class="n">rx</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">ry</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rx</span> <span class="o">==</span> <span class="n">ry</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rx</span> <span class="o">&gt;</span> <span class="n">ry</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">ry</span><span class="p">];</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">size</span><span class="p">[</span><span class="n">ry</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">rx</span><span class="p">];</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">rx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ry</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * An implementation of Kruskal's algorithm which computes
 * the minimum spanning tree of a graph `G`
 *
 * Time complexity: O(m log m)
 * Space complexity: O(m)
 *
 * @param {vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;} g The adjacency list representation
 * of a graph `G`, each entry `g_{ij}` holds a pair which represents an edge
 * (vertex, weight) which tells that there's an edge from `i` to `vertex`
 * with weight `weight`
 * @return {int} The weight of the MST
 */</span>
<span class="kt">int</span> <span class="nf">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
      <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">initialize_sets</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

  <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">set_union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
      <span class="n">total</span> <span class="o">+=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="prims-algorithm">Prim’s algorithm</h3>

<p>For a connected weighted graph $G$ a spanning tree is constructed as follows</p>

<ul>
  <li>for an arbitrary vertex $u$ and edge of minimum weight $e_1$ incident to $u$ is chosen as the first edge of the MST</li>
  <li>for subsequent edges $e_2, e_3, \ldots, e_{n - 1}$ we select an edge of minimum weight among those edges having <strong>exactly one of its vertices incident with an edge already selected</strong></li>
</ul>

<h4 id="prim-in-dense-graphs">Prim in dense graphs</h4>

<p>Let’s say we’re given the following problem</p>

<blockquote>
  <p>given $n$ points in a plane find the skeleton of minimum weight that connects them all</p>
</blockquote>

<p>This problem can be modeled as a graph of order $n$ where each vertex is connected to every other vertex by an edge of weight equal to the euclidean distance between the vertices therefore $m \approx n^2$</p>

<p>Implementation strategies:</p>

<ul>
  <li>we need a data structure that keeps track of a single edge per vertex (space: $O(n)$ and is able to tell the one with the minimum weight (doing $O(n)$ queries), since $m \approx n^2$ we visit each vertex finding an edge with minimum cost (each query will take $O(n)$ for an overall $O(n^2)$ time complexity)</li>
  <li>after an arbitrary vertex $u$ has been chosen all the vertices incident to $u$ will update their minimum edge weight</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * An implementation of Prim's algorithm which computes
 * the minimum spanning tree of a dense graph `G`
 *
 * Time complexity: O(n^2)
 * Space complexity: O(n)
 *
 * @param {vector&lt;vector&lt;int&gt; &gt;} g The adjacency matrix of `G`, each entry `a_{ij}`
 * holds the weight of the edge connecting vertex `i` and vertex `j`, if this number
 * is &lt;= 0 then `i` and `j` are not adjacent
 * @return {int} The weight of the MST
 */</span>
<span class="kt">int</span> <span class="nf">prim</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="c1">// holds the weight of the edge of minimum weight incident
</span>  <span class="c1">// to the vertex `i`
</span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_weight_edge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
  <span class="c1">// (optional) holds the index of a vertex adjacent to the
</span>  <span class="c1">// vertex `i` in the MST, note that the size of the MST is
</span>  <span class="c1">// n - 1 so the first vertex won't store the mentioned index
</span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">neighbor_selected</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// pick the first node as the "arbitrary" node
</span>  <span class="n">min_weight_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// find the vertices which haven't been visited yet
</span>      <span class="c1">// among them find a vertex with the minimum edge weight
</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
          <span class="n">min_weight_edge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_weight_edge</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">min_weight_edge</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>

    <span class="c1">// update the minimum edge weight of all the vertices
</span>    <span class="c1">// adjacent to `v`
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">to</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">to</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
          <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">to</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_weight_edge</span><span class="p">[</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">min_weight_edge</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">to</span><span class="p">];</span>
        <span class="c1">// update the candidate neighbor of the vertex `to` to
</span>        <span class="c1">// be `v` since it's connected with an edge
</span>        <span class="c1">// of minimum weight among all the adjacent vertices to `to`
</span>        <span class="n">neighbor_selected</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<h4 id="prim-in-sparse-graphs">Prim in sparse graphs</h4>

<p>Implementation strategies:</p>

<ul>
  <li>we need a data structure that keeps track of a single edge per vertex (space: $O(n)$ and is able to tell the one with the minimum weight (doing $O(n)$ queries), since $m \approx n$ we analyze each edge finding the one with minimum weight $O(n)$ times, we can use a red-black tree (each operation takes $O(log\;n)$ for an overall $O(m\;log \;n)$ time complexity)</li>
  <li>after an arbitrary vertex $u$ has been chosen all the vertices incident to $u$ will update their minimum edge weight</li>
  <li>the red-black tree will hold $n - 1$ entries at max (one entry per vertex), each iteration a vertex will be removed from the red-black tree</li>
  <li>there will be exactly $n$ iterations if the graph is connected</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * C++11
 *
 * An implementation of Prim's algorithm which computes
 * the minimum spanning tree of a sparse graph `G` of order `n` and size `m`
 *
 * Time complexity: O(m log n)
 * Space complexity: O(n)
 *
 * @param {vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;} g The adjacency list representation
 * of a graph `G`, each entry `g_{ij}` holds a pair which represents an edge
 * (vertex, weight) which tells that there's an edge from `i` to `vertex`
 * with weight `weight`
 * @return {int} The weight of the MST or a negative number if the graph
 * wasn't connected
 */</span>
<span class="kt">int</span> <span class="nf">prim</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="c1">// holds the weight of the edge of minimum weight incident
</span>  <span class="c1">// to the vertex `i`
</span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_cost</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
  <span class="c1">// (optional) holds the index of a vertex adjacent to the
</span>  <span class="c1">// vertex `i` in the MST, note that the size of the MST is
</span>  <span class="c1">// n - 1 so the first vertex won't store the mentioned index
</span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">neighbor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// the first node is the "arbitrary" node for the sake of the implementation
</span>  <span class="n">min_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// (min weight, vertex)
</span>  <span class="n">set</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

    <span class="c1">// the vertex `v` belongs to the MST and is adjacent
</span>    <span class="c1">// to the vertex `neighbor[v]` with and edge
</span>    <span class="c1">// of weight `weight`
</span>    <span class="n">total</span> <span class="o">+=</span> <span class="n">q</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>

    <span class="n">q</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">next</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

      <span class="c1">// note that in the graph the first element is the neighbor vertex
</span>      <span class="c1">// but in the set the first element is the edge weight
</span>      <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">[</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">erase</span><span class="p">({</span> <span class="n">min_cost</span><span class="p">[</span><span class="n">to</span><span class="p">],</span> <span class="n">to</span> <span class="p">});</span>
        <span class="n">min_cost</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">neighbor</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="n">min_cost</span><span class="p">[</span><span class="n">to</span><span class="p">],</span> <span class="n">to</span> <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// check that every vertex has a min cost edge associated
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">min_cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<h2 id="number-of-spanning-trees-in-a-graph">Number of spanning trees in a graph</h2>

<p>Let $G$ be a graph with $V(G) = {v_1, v_2, \ldots, v_n}$, let $A = [a_{ij}]$ be the adjacency matrix of $G$ and let $C = [c_{ij}]$ be a $n \times n$ matrix where</p>

<script type="math/tex; mode=display">% <![CDATA[
c_{ij} = \begin{cases}
deg\;v_i & \text{if $i = j$} \\
-a_{ij} & \text{if $i \neq j$} \\
\end{cases} %]]></script>

<p>Then the number of spanning trees of $G$ is the value of any cofactor of $C$</p>

<p>The matrix of cofactors a $n \times n$ matrix $C = [c_{ij}]$ where</p>

<script type="math/tex; mode=display">c_{ij} = (-1)^{i + j} \cdot det(M_{ij})</script>

<p>$det(M_{ij})$ indicates the determinant of the $(n - 1) \times (n - 1)$ submatrix of $M$ obtained by removing the $i$-th row and the $j$-th column</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * Given a square matrix M of size (n x n) this method
 * computes the a matrix of size (n - 1) x (n - 1) by eliminating
 * the elements belonging to the `row` row of M and the `col`
 * column of M
 *
 * @param {vector&lt;vector&lt;int&gt; &gt; } m The square matrix
 * @param {int} row The row to be ignored
 * @param {int} col The column to be ignored
 * @return {vector&lt;vector&lt;int&gt; &gt;} the value of the determinant
 */</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">minor</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

  <span class="kt">int</span> <span class="n">trow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">tcol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">t</span><span class="p">[</span><span class="n">trow</span><span class="p">][</span><span class="n">tcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
      <span class="n">tcol</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">trow</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * Computes the determinant of an square matrix
 *
 * @param {vector&lt;vector&lt;int&gt; &gt; } m The square matrix
 * @return {int} the value of the determinant
 */</span>
<span class="kt">int</span> <span class="n">determinant</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">minor</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">determinant</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * Computes the number of spanning trees in an undirected graph `G`
 *
 * @param &lt;vector&lt;vector&lt;int&gt; &gt; &gt; g The adjacency matrix of `G`
 * @return {int} The number of spanning trees
 */</span>
<span class="kt">int</span> <span class="n">number_of_spanning_trees</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// -a_{ij} for elements that are not in the main diagonal
</span>    <span class="kt">int</span> <span class="n">degree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
          <span class="n">degree</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// deg v_i for t[i][i]
</span>    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// compute the (0,0) cofactor
</span>  <span class="c1">// c_{0, 0} = (-1)^{0 + 0} * determinant((0, 0) minor)
</span>  <span class="c1">//          = determinant((0, 0) minor)
</span>  <span class="k">return</span> <span class="n">determinant</span><span class="p">(</span><span class="n">minor</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="number-of-spanning-trees-in-a-complete-graph-kn">Number of spanning trees in a complete graph $K_n$</h3>

<p>Computing the number of spanning trees of a graph $G = K_n$ where $V(G) = {v_1, v_2, \ldots, v_n}$ is the same as computing the number of distinct trees with vertex set ${v_1, v_2, \ldots, v_n}$, the formula is called the <strong>Caley Tree Formula</strong></p>

<blockquote>
  <p>The number of spanning trees of order $n$ with a specific vertex set is $n^{n - 2}$</p>
</blockquote>

<p>TODO:</p>

<ul>
  <li>find the relationship between prim’s mst and dijsktra’s</li>
  <li>second minimum spanning tree, hint: MST + LCA http://codeforces.com/blog/entry/9570</li>
</ul>

<script>
(function () {
  d3.json('/js/graph/data/spanning-tree.json', function (err, data) {
    if (err) { throw err }
    greuler({
      target: '#figure-spanning-tree',
      data: data
    }).update()
  })

  d3.json('/js/graph/data/minimum-spanning-tree.json', function (err, data) {
    if (err) { throw err }
    greuler({
      target: '#figure-minimum-spanning-tree',
      data: data
    }).update()
  })
})();
</script>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!-- <h2 class="footer-heading">Mauricio Poppe</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Mauricio Poppe</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/maurizzzio">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">maurizzzio</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/iMauricio">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">iMauricio</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Layout run failed ._.
</p>
      </div>
    </div>

  </div>

  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: 'none',
    tex2jax: {
      // http://docs.mathjax.org/en/latest/options/tex2jax.html
      inlineMath: [['$','$']],
      displayMath: [['$$','$$']]
      // processEnvironments: false
    },
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      Macros: {
        edge: '\\mathrel{-}',
        notedge: '\\not\\edge',
        deg: ['#1^{\\circ}', 1],
        tbold: ['\\textbf{#1}', 1],
        mbold: ['\\mathbf{#1}', 1],
        unit: ['\\widehat{\\mathbf{#1}}', 1],

        magnitude: ['\\left \\| #1 \\right \\|', 1],
        norm: ['\\left \\| #1 \\right \\|', 1]
      }
    },
    'HTML-CSS': {
      imageFont: null
    }
  });
</script>

<script type="text/javascript">
/*
 * MathJax eqn preview for a tags
 *
 * Copyright (c) 2015 Mauricio Poppe
 * Licensed under the MIT license.
 */

(function () {
  var $container = $('.post-content');
  var $tooltip = $('<div />').addClass('mathjax-tooltip');
  $container.append($tooltip);

  function onMouseOver(ev) {
    var a = ev.currentTarget;
    var $number = $(a.hash);
    var $root = $number.closest('.MathJax_Display');
    var bounds = $(a).offset();
    var containerBounds = $container.offset();

    $tooltip.stop(true, true);
    $tooltip.empty();
    $tooltip.append($root.clone());
    $tooltip.css({
      top: bounds.top - containerBounds.top - $tooltip.height() - 5,
      left: -1
    });
    $tooltip.addClass('active');
  }

  function onMouseOut(a) {
    $tooltip.removeClass('active');
  }

  MathJax.Hub.Queue(function () {
    $container.on('mouseover', 'a[href*="mjx-eqn-"]', onMouseOver);
    $container.on('mouseout', 'a[href*="mjx-eqn-"]', onMouseOut);
  });

})();
</script>

</footer>


  </body>

</html>
