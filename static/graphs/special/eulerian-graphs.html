<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Eulerian Graph</title>
  <meta name="description" content="Layout run failed ._.
">

  <!-- syntax highlighter -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://maurizzzio.github.io/static/graphs/special/eulerian-graphs.html">
  <link rel="alternate" type="application/rss+xml" title="Mauricio Poppe" href="http://maurizzzio.github.io/feed.xml" />

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mauricio Poppe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

<!--       <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a>
          
        
          
          <a class="page-link" href="/static/graphs/components.html">Components</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/derivative.html">Derivative</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/divisor-function.html">Divisor Function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a>
          
        
          
          <a class="page-link" href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/tree/index.html">Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/integral.html">Integral</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/introduction.html">Introduction</a>
          
        
          
          <a class="page-link" href="/static/graphs/introduction.html">Introduction</a>
          
        
          
        
          
          <a class="page-link" href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/primality-test.html">Primality Test</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a>
          
        
          
          <a class="page-link" href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a>
          
        
          
          <a class="page-link" href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a>
          
        
          
          <a class="page-link" href="/static/graphs/topological-sorting.html">Topological sorting</a>
          
        
          
          <a class="page-link" href="/static/graphs/traversal.html">Traversal</a>
          
        
      </div>
 -->
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="static-page-sidebar">
        <ul><li><a href="/index.html"></a><ul><li>static<ul><li>graphs<ul><li><a href="/static/graphs/introduction.html">Introduction</a><ul></ul></li><li><a href="/static/graphs/traversal.html">Traversal</a><ul></ul></li><li><a href="/static/graphs/topological-sorting.html">Topological sorting</a><ul></ul></li><li><a href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a><ul></ul></li><li><a href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a><ul></ul></li><li><a href="/static/graphs/components.html">Components</a><ul></ul></li><li><a href="/static/graphs/tree/index.html">Tree</a><ul><li><a href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a><ul></ul></li></ul></li><li><a href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a><ul></ul></li><li>special<ul><li><a href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a><ul></ul></li><li><a href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a><ul></ul></li></ul></li></ul></li><li>math<ul><li>calculus<ul><li><a href="/static/math/calculus/introduction.html">Introduction</a><ul></ul></li><li><a href="/static/math/calculus/derivative.html">Derivative</a><ul></ul></li><li><a href="/static/math/calculus/integral.html">Integral</a><ul></ul></li><li><a href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a><ul></ul></li></ul></li><li>number-theory<ul><li><a href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a><ul></ul></li><li><a href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a><ul></ul></li><li><a href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a><ul></ul></li><li><a href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a><ul></ul></li><li><a href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a><ul></ul></li><li><a href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a><ul></ul></li><li><a href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a><ul></ul></li><li><a href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a><ul></ul></li><li><a href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a><ul></ul></li><li><a href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a><ul></ul></li><li><a href="/static/math/number-theory/primality-test.html">Primality Test</a><ul></ul></li><li><a href="/static/math/number-theory/divisor-function.html">Divisor Function</a><ul></ul></li><li><a href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a><ul></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
      </div>

      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Eulerian Graph</h1>
  </header>

  <article class="post-content">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script src="//maurizzzio.github.io/greuler/scripts/lib/cola.v3.js"></script>

<script src="//maurizzzio.github.io/greuler/greuler.js"></script>

<p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$ (remember that a circuit is a closed trail, i.e. a walk in which no edge is traversed more than once and it and that it begins and ends in the same vertex)</p>

<ul>
  <li>every edge of $G$ appears only once in the circuit</li>
  <li>only graphs with one component can contain such a circuit</li>
</ul>

<p>A connected graph $G$ that contains an eulerian circuit $C$ is called an <strong>Eulerian Graph</strong></p>

<div id="figure-eulerian-graph"></div>

<script type="math/tex; mode=display">C = (v_0,v_1,v_2,v_3,v_1,v_6,v_3,v_4,v_5,v_6,v_7,v_5,v_8,v_7,v_{10},v_8,v_9,v_{10},v_0)</script>

<p>An <strong>Eulerian trail</strong> is an open trail $T$ that contains all the edges of $G$ (but doesnâ€™t end in the same start vertex)</p>

<div id="figure-eulerian-trail"></div>

<script type="math/tex; mode=display">T = (v_0,v_1,v_2,v_4,v_3,v_1,v_4,v_5)</script>

<h2 id="knigsberg-bridge-problem">KÃ¶nigsberg Bridge Problem</h2>

<p>The city of KÃ¶nigsberg, located in Prussia was separated by a river in 4 land areas, to travel between these areas 7 bridges were built, some citizens wondered whether it was possible to go for a walk in KÃ¶nigsberg and pass over each bridge exactly once</p>

<div id="figure-konigsberg-bridges"></div>

<div style="width: 500px" class="center">
The land areas and the bridges built in the city of KÃ¶nigsberg modeled as a graph $M$
</div>

<p><br /></p>

<p>In graph theory terms the problem can be stated as follows</p>

<blockquote>
  <p>Does the multigraph $M$ of order $n = 4$ and size $m = 7$ contain an Eulerian circuit or an Eulerian trail?</p>
</blockquote>

<p>Suppose that such a journey is possible then it must begin at some land area and end at some land area (possibly the same one), certainly each land area must appear in the trail, note that at least two vertices of $M$ are neither the initial nor the terminal vertex of the trail, letâ€™s say that we start at land $A$ and end at land $A$</p>

<script type="math/tex; mode=display">T = (A, L_1, L_2, L_3, L_4, L_5, L_6, A)</script>

<p>Each of the $L$ lands but the first and the last are entered and exited every time they appear in the trail, this implies that all $L$ lands must have an even degree for a trail to exist</p>

<p>Going back to the KÃ¶nigsberg bridge problem we can see that itâ€™s impossible to find a trail because all the vertices have an odd degree</p>

<ul>
  <li>The length of the eulerian circuit/trail of a graph $G$ is equal to $m + 1$ where $m$ is the size of $G$</li>
</ul>

<p>For undirected graphs</p>

<ul>
  <li>A graph $G$ is an <strong>Eulerian graph</strong> if and only if every vertex of $G$ has even degree</li>
  <li>A graph $G$ contains an <strong>Eulerian trail</strong> if and only if exactly <strong>2 vertices</strong> of $G$ have odd degree, also each trail of $G$ begins at one of these vertices and ends at the other</li>
</ul>

<p>For directed graphs</p>

<ul>
  <li>A graph $G$ is an <strong>Eulerian graph</strong> if and only if every vertex of $G$ has the same incoming degree and outgoing degree values and itâ€™s strongly connected</li>
  <li>A graph $G$ contains an <strong>Eulerian trail</strong> if and only if for each vertex the difference between its incoming degrees and outgoing degrees is 0 except for 2 vertices whose difference is $-1$ (start) and $+1$ (end), if those edges are connected by an edge then the graph is strongly connected</li>
</ul>

<h2 id="hierholzers-algorithm">Hierholzerâ€™s algorithm</h2>

<p>Let $C$ be a cycle in an Eulerian graph, removing $E(C)$ from $G$ will create a subgraph which has an Eulerian trail</p>

<ol>
  <li>identify a circuit $C$ in $G$, mark the edges of $C$</li>
  <li>if $C$ contains all the edges of $G$ then stop</li>
  <li>otherwise let $v_i$ be a node on $C$ that is incident with an unmarked edge $e_i$</li>
  <li>build a circuit $D$ starting at node $v_i$ and using edge $e_1$, mark the edges of $D$</li>
  <li>join the circuit $D$ to $C$ by inserting the edges of $D$ into $C$ at position $v_1$, move to step 2</li>
</ol>

<h3 id="implementation-notes">Implementation notes</h3>

<p>In the implementation a source vertex $u$ is chosen to be arbitrary or to be the one of the two odd degree vertices, then an edge $uv$ is marked as visited, then we move to the vertex $v$, next an edge $vw$ is marked as visited, eventually we will get to a vertex $z$ that doesnâ€™t have unvisited edges, this means that thereâ€™s a circuit starting at vertex $z$ and ending at vertex $z$, next there might be one vertex $y$ in the circuit $z-z$ that has unvisited edges, if one is found we know that thereâ€™s other circuit $y-y$, both circuits $z-z$ and $y-y$ might have nested circuits themselves, when the $y-y$ circuit doesnâ€™t have a vertex with unvisited edges then the result is appended to the main circuit $z-z$ i.e. $u-v-\ldots-z-y-y-z$</p>

<style>
#stack, #trail {
  height: 40px;
}
#figure-find-eulerian-trail span {
  width: 50px;
  border: 1px solid #999;
  padding: 5px 10px;
}
</style>

<div id="figure-find-eulerian-trail">
  <div class="overlay" style="position: absolute"></div>
  <div id="stack">
    stack:
  </div>
  <div id="trail">
    trail:
  </div>
</div>

<pre><code class="language-cpp">// each edge is saved by id, helper to avoid the traversal
// of an edge many times
vector&lt;bool&gt; edge_used;
// the number of edges used in the adjacency list of the vertex `i`
vector&lt;int&gt; edge_pointer;
// the eulerian trail
vector&lt;int&gt; trail;
// the adjacency list representation of `g`, each element `g_{i,j}` is
// a tuple (to, id) which denotes an edge `(i, to)` with id `id`
vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; g;

void dfs(int v) {
  for (; edge_pointer[v] &lt; g[v].size(); edge_pointer[v] += 1) {
    pair&lt;int, int&gt; &amp;edge = g[v][edge_pointer[v]];
    if (edge_used[edge.second]) {
      // if the edge was already used analyze the next one
      continue;
    }
    // mark the edge
    edge_used[edge.second] = true;
    dfs(edge.first);
  }
  trail.push_back(v);
}

/**
 * Computes an euler trail if possible in an undirected graph `G`
 * whose `edges` are given as an input
 *
 * NOTE: The trail if it exists is saved on the global `trail`
 *
 * @param {int} n The order of the graph
 * @param {vector&lt;pair&lt;int, int&gt; &gt;} A collection of tuples
 * denoting the indexes of the vertices the edge `i` is incident to
 * @return {bool} True if the graph has an euler trail
 */
bool euler_trail_undirected(int n, vector&lt;pair&lt;int, int&gt; &gt; &amp;edges) {
  int m = edges.size();
  g.assign(n, vector&lt;pair&lt;int, int&gt; &gt; ());
  edge_pointer.assign(n, 0);
  edge_used.assign(m, 0);
  vector&lt;int&gt; deg(n, 0);

  // build the adjacency list of the graph
  for (int i = 0; i &lt; m; i += 1) {
    int u = edges[i].first;
    int v = edges[i].second;
    g[u].push_back({ v, i });
    g[v].push_back({ u, i });
    deg[u] += 1;
    deg[v] += 1;
  }

  // find an odd vertex
  int start = 0;
  int odd_degree_count = 0;
  for (int i = 0; i &lt; n; i += 1) {
    if (deg[i] % 2 != 0) {
      ++odd_degree_count;
      start = i;
    }
  }

  if (odd_degree_count == 2 || odd_degree_count == 0) {
    dfs(start);
    return trail.size() == m + 1;
  }
  return false;
}


/**
 * Computes an euler trail if possible in an directed graph `G`
 * whose `edges` are given as an input
 *
 * NOTE: The trail if it exists is saved on the global `trail`
 *
 * @param {int} n The order of the graph
 * @param {vector&lt;pair&lt;int, int&gt; &gt;} A collection of tuples
 * denoting the indexes of the vertices the edge `i` is incident to
 * @return {bool} True if the graph has an euler trail
 */
bool euler_trail_directed(int n, vector&lt;pair&lt;int, int&gt; &gt; &amp;edges) {
  int m = edges.size();
  g.assign(n, vector&lt;pair&lt;int, int&gt; &gt; ());
  edge_pointer.assign(n, 0);
  edge_used.assign(m, 0);
  vector&lt;int&gt; in_deg(n, 0), out_deg(n, 0);

  // build the adjacency list of the graph
  for (int i = 0; i &lt; m; i += 1) {
    int u = edges[i].first;
    int v = edges[i].second;
    g[u].push_back({ v, i });
    out_deg[u] += 1;
    in_deg[v] += 1;
  }

  // find an odd vertex
  int start = 0;
  int odd_degree_count = 0;
  for (int i = 0; i &lt; n; i += 1) {
    if (in_deg[i] - out_deg[i] != 0) {
      ++odd_degree_count;
      if (out_deg[i] &gt; in_deg[i]) {
        start = i;
      }
    }
  }

  if (odd_degree_count == 2 || odd_degree_count == 0) {
    dfs(start);
    return trail.size() == m + 1;
  }
  return false;
}

</code></pre>

<script>
(function () {
  d3.json('/js/graph/data/eulerian-graph.json', function (error, data) {
    greuler({
      target: '#figure-eulerian-graph',
      data: data
    }).update();
  });
  d3.json('/js/graph/data/eulerian-trail.json', function (error, data) {
    greuler({
      target: '#figure-eulerian-trail',
      data: data
    }).update();
  });
  d3.json('/js/graph/data/konigsberg-bridges.json', function (error, data) {
    greuler({
      target: '#figure-konigsberg-bridges',
      data: data
    }).update();
  });

  d3.json('/js/graph/data/eulerian-graph.json', function (error, data) {
    var options = {
      target: '#figure-find-eulerian-trail',
      data: data
    };

    var instance = greuler(options).update();

    // vertices in trail
    var trailEl = d3.select(options.target).append('div');

    var edge_pointer = [];
    var edge_id = {};
    var g = [];
    var n, m;

    var trail = [];
    var stack = [];

    function stackAnimation () {
      var stackSelection = d3.select('#stack').selectAll('span')
        .data(stack)
      stackSelection.enter()
        .append('span')
        .style('opacity', 0)
        .text(function (d) { return d; })
      .transition()
        .style('opacity', 1);
      stackSelection.exit()
        .transition()
        .style('opacity', 0)
        .remove();

      d3.select('#trail').selectAll('span')
        .data(trail)
        .enter()
        .append('span')
        .style('opacity', 0)
        .text(function (d) { return d; })
      .transition()
        .style('opacity', 1);
    }

    function euler () {
      var player = new greuler.player.Generator(instance);
      player.run(function *algorithm(instance) {
        function *eulerianTrail(u) {
          // stack manipulation/animation
          stack.push(u);
          stackAnimation();

          yield function () {
            instance.selector.getNode({ id: u })
              .transition()
              .attr('fill', 'black');
          }

          var edges = instance.graph.getIncidentEdges({ id: u });
          for (var i = 0; i < edges.length; i += 1) {
            var e = edges[i];
            var next = e.target.id === u ? e.source.id : e.target.id;

            if (e.used) { continue; }
            e.used = true;

            yield function () {
              instance.selector.traverseAllEdgesBetween(
                { source: u, target: next },
                { keepStroke: false }
              )
            }

            yield* eulerianTrail(next);
          }

          // stack manipulation/animation
          trail.push(stack.pop());

          yield function () {
            if (trail.length > 1) {
              instance.selector.traverseAllEdgesBetween(
                { source: trail[trail.length - 2], target: trail[trail.length - 1] }
              )
            }
          }

          stackAnimation();

          yield function () {
            instance.selector.getNode({ id: u })
              .transition()
              .attr('fill', '#2980B9');
          }
        }
        yield* eulerianTrail(0);

        // node traversal is given by trail
        // for (var i = 0; i < trail.length; i += 1) {
        //   yield function () {
        //     instance.selector.traverseAllEdgesBetween(
        //       { source: trail[i], target: trail[i + 1] }
        //     );
        //   };
        // }
      });
    }

    // function* dfs(v) {
    //   yield function () {
    //     instance.selector.getNode({ id: v })
    //       .transition()
    //       .attr('fill', 'black');
    //   }

    //   for (; edge_pointer[v] < g[v].length; edge_pointer[v] += 1) {
    //     var edge = g[v][edge_pointer[v]];
    //     if (edge_id[edge.id]) {
    //       continue;
    //     }

    //     yield function () {
    //       instance.selector.traverseAllEdgesBetween(
    //         { source: v, target: edge.id }
    //       )
    //     }

    //     edge_id[edge.id] = true;
    //     yield* dfs(edge.to);
    //   }
    // }

    // function euler() {
    //   var i;
    //   for (i = 0; i < data.nodes.length; i += 1) {
    //     g[i] = [];
    //     edge_pointer[i] = 0;
    //   }
    //   for (i = 0; i < data.links.length; i += 1) {
    //     var u = data.links[i].source.index;
    //     var v = data.links[i].target.index;
    //     g[u].push({ to: v, id: data.links[i].id });
    //     g[v].push({ to: u, id: data.links[i].id });
    //   }

    //   var iterator = dfs(0);

    //   function run() {
    //     var next = iterator.next();
    //     if (!next.done) {
    //       // highlight edge
    //       if (next.value.command === 'edge') {
    //         var edges = data.links;
    //         var i;
    //         var id = next.value.edge;
    //         for (i = 0; i < edges.length; i += 1) {
    //           if (edges[i].id === id) {
    //             break;
    //           }
    //         }
    //         edges[i]["class"] = "highlight";
    //       } else {
    //         if (next.value.command === 'push') {
    //           stack.push(next.value.node);
    //         } else {
    //           trail.push(stack.pop());
    //         }

    //         // stack animations
    //         var stackSelection = d3.select('#stack').selectAll('span')
    //           .data(stack)
    //         stackSelection.enter()
    //           .append('span')
    //           .style('opacity', 0)
    //           .text(function (d) { return d; })
    //         .transition()
    //           .style('opacity', 1);
    //         stackSelection.exit()
    //           .transition()
    //           .style('opacity', 0)
    //           .remove();

    //         d3.select('#trail').selectAll('span')
    //           .data(trail)
    //           .enter()
    //           .append('span')
    //           .style('opacity', 0)
    //           .text(function (d) { return d; })
    //         .transition()
    //           .style('opacity', 1);
    //       }
    //       instance.update();
    //       setTimeout(run, 1000);
    //     }
    //   }
    //   run();
    // }

    var root = d3.select(options.target).node();
    var trackRun = false;
    document.addEventListener('scroll', function (e) {
      var scrollTop = window.scrollY;
      if (!trackRun && scrollTop + window.innerHeight >= root.offsetTop + root.clientHeight) {
        trackRun = true;
        // var el = d3.select('.overlay');
        // var parent = el.node().parentNode;
        // el.style('width', parent.clientWidth + 'px');
        // el.style('height', parent.clientHeight + 'px');
        euler();
        d3.select(options.target)
          .selectAll('svg')
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1)
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1)
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1);
      }
    });
  });

})();
</script>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Mauricio Poppe</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Mauricio Poppe</li>
          <li><a href="mailto:mauricio.poppe@gmail.com">mauricio.poppe@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/maurizzzio">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">maurizzzio</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/iMauricio">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">iMauricio</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Layout run failed ._.
</p>
      </div>
    </div>

  </div>

  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: 'none',
    tex2jax: {
      // http://docs.mathjax.org/en/latest/options/tex2jax.html
      inlineMath: [['$','$']],
      displayMath: [['$$','$$']]
      // processEnvironments: false
    },
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      Macros: {
        edge: '\\mathrel{-}',
        notedge: '\\not\\edge'
      }
    },
    'HTML-CSS': {
      imageFont: null
    }
  });
</script>

<script type="text/javascript">
/*
 * MathJax eqn preview for a tags
 *
 * Copyright (c) 2015 Mauricio Poppe
 * Licensed under the MIT license.
 */

(function () {
  var $container = $('.post-content');
  var $tooltip = $('<div />').addClass('mathjax-tooltip');
  $container.append($tooltip);

  function onMouseOver(ev) {
    var a = ev.currentTarget;
    var $number = $(a.hash);
    var $root = $number.closest('.MathJax_Display');
    var bounds = $(a).offset();
    var containerBounds = $container.offset();

    $tooltip.stop(true, true);
    $tooltip.empty();
    $tooltip.append($root.clone());
    $tooltip.css({
      top: bounds.top - containerBounds.top - $tooltip.height() - 5,
      left: -1
    });
    $tooltip.addClass('active');
  }

  function onMouseOut(a) {
    $tooltip.removeClass('active');
  }

  MathJax.Hub.Queue(function () {
    $container.on('mouseover', 'a[href*="mjx-eqn-"]', onMouseOver);
    $container.on('mouseout', 'a[href*="mjx-eqn-"]', onMouseOut);
  });

})();
</script>

</footer>


  </body>

</html>
