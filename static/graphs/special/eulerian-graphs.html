<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Eulerian Graph</title>
  <meta name="description" content="Layout run failed ._.
">

  <!-- syntax highlighter -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://maurizzzio.github.io//static/graphs/special/eulerian-graphs.html">
  <link rel="alternate" type="application/rss+xml" title="Mauricio Poppe" href="http://maurizzzio.github.io//feed.xml" />

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mauricio Poppe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

<!--       <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/combining-transformations.html">Combining transformations</a>
          
        
          
          <a class="page-link" href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a>
          
        
          
          <a class="page-link" href="/static/graphs/components.html">Components</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a>
          
        
          
          <a class="page-link" href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/derivative.html">Derivative</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/divisor-function.html">Divisor Function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a>
          
        
          
          <a class="page-link" href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a>
          
        
          
        
          
          <a class="page-link" href="/static/graphs/tree/">Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/integral.html">Integral</a>
          
        
          
          <a class="page-link" href="/static/graphs/introduction.html">Introduction</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/introduction.html">Introduction</a>
          
        
          
        
          
          <a class="page-link" href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/orthographic-projection.html">Orthographic projection</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/perspective-projection.html">Perspective projection</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/primality-test.html">Primality Test</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/opengl/projection-matrix.html">Projection matrix</a>
          
        
          
          <a class="page-link" href="/static/math/geometry/projective-geometry.html">Projective Geometry</a>
          
        
          
          <a class="page-link" href="/static/math/numeral-systems/quaternions.html">Quaternions</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/rotation/quaternions.html">Quaternions</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/fundamentals/ray-tracing.html">Ray tracing</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/fundamentals/rendering.html">Rendering</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/resources.html">Resources</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/rotation.html">Rotations</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/scale.html">Scale</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/shearing.html">Shearing</a>
          
        
          
          <a class="page-link" href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/space-coordinates.html">Space coordinates</a>
          
        
          
          <a class="page-link" href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a>
          
        
          
          <a class="page-link" href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a>
          
        
          
          <a class="page-link" href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a>
          
        
          
          <a class="page-link" href="/static/graphs/topological-sorting.html">Topological sorting</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/math/translation.html">Translation</a>
          
        
          
          <a class="page-link" href="/static/graphs/traversal.html">Traversal</a>
          
        
          
          <a class="page-link" href="/static/computer-graphics/opengl/view-matrix.html">View matrix</a>
          
        
      </div>
 -->
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="static-page-sidebar">
        <ul><li><li><ul><li>static<ul><li>computer-graphics<ul><li><a href="/static/computer-graphics/resources.html">Resources</a></li><li>fundamentals<ul><li><a href="/static/computer-graphics/fundamentals/rendering.html">Rendering</a></li><li><a href="/static/computer-graphics/fundamentals/ray-tracing.html">Ray tracing</a></li></ul></li><li>math<ul><li><a href="/static/computer-graphics/math/space-coordinates.html">Space coordinates</a></li><li><a href="/static/computer-graphics/math/scale.html">Scale</a></li><li><a href="/static/computer-graphics/math/shearing.html">Shearing</a></li><li><a href="/static/computer-graphics/math/rotation.html">Rotations</a></li><li><a href="/static/computer-graphics/math/translation.html">Translation</a></li><li><a href="/static/computer-graphics/math/orthographic-projection.html">Orthographic projection</a></li><li><a href="/static/computer-graphics/math/perspective-projection.html">Perspective projection</a></li><li><a href="/static/computer-graphics/math/combining-transformations.html">Combining transformations</a></li><li>rotation<ul><li><a href="/static/computer-graphics/math/rotation/quaternions.html">Quaternions</a></li></ul></li></ul></li><li>opengl<ul><li><a href="/static/computer-graphics/opengl/view-matrix.html">View matrix</a></li><li><a href="/static/computer-graphics/opengl/projection-matrix.html">Projection matrix</a></li></ul></li></ul></li><li>graphs<ul><li><a href="/static/graphs/introduction.html">Introduction</a></li><li><a href="/static/graphs/traversal.html">Traversal</a></li><li><a href="/static/graphs/topological-sorting.html">Topological sorting</a></li><li><a href="/static/graphs/cut-edges.html">Cut-edges (bridges)</a></li><li><a href="/static/graphs/cut-vertices.html">Cut-vertices (articulation points)</a></li><li><a href="/static/graphs/components.html">Components</a></li><li><a href="/static/graphs/single-source-shortest-path.html">Single Source Shortest Path (SSSP)</a></li><li>special<ul><li><a href="/static/graphs/special/eulerian-graphs.html">Eulerian Graph</a></li><li><a href="/static/graphs/special/hamiltonian_graphs.html">Hamiltonian Graphs</a></li></ul></li><li>tree<ul><li><a href="/static/graphs/tree/spanning-tree.html">Spanning Tree</a></li></ul></li></ul></li><li>math<ul><li>calculus<ul><li><a href="/static/math/calculus/introduction.html">Introduction</a></li><li><a href="/static/math/calculus/derivative.html">Derivative</a></li><li><a href="/static/math/calculus/integral.html">Integral</a></li><li><a href="/static/math/calculus/taylor-theorem-infinite-series.html">Taylor's Theorem and Infinite Series</a></li></ul></li><li>geometry<ul><li><a href="/static/math/geometry/projective-geometry.html">Projective Geometry</a></li></ul></li><li>number-theory<ul><li><a href="/static/math/number-theory/eulers-phi.html">Euler's phi function</a></li><li><a href="/static/math/number-theory/binary-exponentiation.html">Binary Exponentiation</a></li><li><a href="/static/math/number-theory/erathostenes-sieve.html">Erathostenes Sieve</a></li><li><a href="/static/math/number-theory/euclidean-algorithm.html">Euclidean Algorithm</a></li><li><a href="/static/math/number-theory/extended-euclidean-algorithm.html">Extended Euclidean Algorithm</a></li><li><a href="/static/math/number-theory/modular-arithmetic.html">Modular Arithmetic</a></li><li><a href="/static/math/number-theory/chinese-remainder-theorem.html">Chinese Remainder Theorem</a></li><li><a href="/static/math/number-theory/discrete-logarithm.html">Discrete Logarithm</a></li><li><a href="/static/math/number-theory/special-factorial-modulo-m.html">Special factorial modulo p</a></li><li><a href="/static/math/number-theory/prime-factors-factorial.html">Prime factors of a factorial</a></li><li><a href="/static/math/number-theory/primality-test.html">Primality Test</a></li><li><a href="/static/math/number-theory/divisor-function.html">Divisor Function</a></li><li><a href="/static/math/number-theory/integer-factorization.html">Integer Factorization</a></li></ul></li><li>numeral-systems<ul><li><a href="/static/math/numeral-systems/complex-numbers.html">Complex numbers</a></li><li><a href="/static/math/numeral-systems/quaternions.html">Quaternions</a></li></ul></li></ul></li></ul></li></ul></li></li></ul>
      </div>

      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Eulerian Graph</h1>
  </header>

  <article class="post-content">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script src="//maurizzzio.github.io/greuler/scripts/lib/cola.v3.js"></script>

<script src="//maurizzzio.github.io/greuler/greuler.js"></script>

<p>A circuit $C$ in a graph $G$ is called an <strong>Eulerian circuit</strong> if $C$ contains every edge of $G$ (remember that a circuit is a closed trail, i.e. a walk in which no edge is traversed more than once and it and that it begins and ends in the same vertex)</p>

<ul>
  <li>every edge of $G$ appears only once in the circuit</li>
  <li>only graphs with one component can contain such a circuit</li>
</ul>

<p>A connected graph $G$ that contains an eulerian circuit $C$ is called an <strong>Eulerian Graph</strong></p>

<div id="figure-eulerian-graph"></div>

<script type="math/tex; mode=display">C = (v_0,v_1,v_2,v_3,v_1,v_6,v_3,v_4,v_5,v_6,v_7,v_5,v_8,v_7,v_{10},v_8,v_9,v_{10},v_0)</script>

<p>An <strong>Eulerian trail</strong> is an open trail $T$ that contains all the edges of $G$ (but doesn’t end in the same start vertex)</p>

<div id="figure-eulerian-trail"></div>

<script type="math/tex; mode=display">T = (v_0,v_1,v_2,v_4,v_3,v_1,v_4,v_5)</script>

<h2 id="knigsberg-bridge-problem">Königsberg Bridge Problem</h2>

<p>The city of Königsberg, located in Prussia was separated by a river in 4 land areas, to travel between these areas 7 bridges were built, some citizens wondered whether it was possible to go for a walk in Königsberg and pass over each bridge exactly once</p>

<div id="figure-konigsberg-bridges"></div>

<div style="width: 500px" class="center">
The land areas and the bridges built in the city of Königsberg modeled as a graph $M$
</div>

<p><br /></p>

<p>In graph theory terms the problem can be stated as follows</p>

<blockquote>
  <p>Does the multigraph $M$ of order $n = 4$ and size $m = 7$ contain an Eulerian circuit or an Eulerian trail?</p>
</blockquote>

<p>Suppose that such a journey is possible then it must begin at some land area and end at some land area (possibly the same one), certainly each land area must appear in the trail, note that at least two vertices of $M$ are neither the initial nor the terminal vertex of the trail, let’s say that we start at land $A$ and end at land $A$</p>

<script type="math/tex; mode=display">T = (A, L_1, L_2, L_3, L_4, L_5, L_6, A)</script>

<p>Each of the $L$ lands but the first and the last are entered and exited every time they appear in the trail, this implies that all $L$ lands must have an even degree for a trail to exist</p>

<p>Going back to the Königsberg bridge problem we can see that it’s impossible to find a trail because all the vertices have an odd degree</p>

<ul>
  <li>The length of the eulerian circuit/trail of a graph $G$ is equal to $m + 1$ where $m$ is the size of $G$</li>
</ul>

<p>For undirected graphs</p>

<ul>
  <li>A graph $G$ is an <strong>Eulerian graph</strong> if and only if every vertex of $G$ has even degree</li>
  <li>A graph $G$ contains an <strong>Eulerian trail</strong> if and only if exactly <strong>2 vertices</strong> of $G$ have odd degree, also each trail of $G$ begins at one of these vertices and ends at the other</li>
</ul>

<p>For directed graphs</p>

<ul>
  <li>A graph $G$ is an <strong>Eulerian graph</strong> if and only if every vertex of $G$ has the same incoming degree and outgoing degree values and it’s strongly connected</li>
  <li>A graph $G$ contains an <strong>Eulerian trail</strong> if and only if for each vertex the difference between its incoming degrees and outgoing degrees is 0 except for 2 vertices whose difference is $-1$ (start) and $+1$ (end), if those edges are connected by an edge then the graph is strongly connected</li>
</ul>

<h2 id="hierholzers-algorithm">Hierholzer’s algorithm</h2>

<p>Let $C$ be a cycle in an Eulerian graph, removing $E(C)$ from $G$ will create a subgraph which has an Eulerian trail</p>

<ol>
  <li>identify a circuit $C$ in $G$, mark the edges of $C$</li>
  <li>if $C$ contains all the edges of $G$ then stop</li>
  <li>otherwise let $v_i$ be a node on $C$ that is incident with an unmarked edge $e_i$</li>
  <li>build a circuit $D$ starting at node $v_i$ and using edge $e_1$, mark the edges of $D$</li>
  <li>join the circuit $D$ to $C$ by inserting the edges of $D$ into $C$ at position $v_1$, move to step 2</li>
</ol>

<h3 id="implementation-notes">Implementation notes</h3>

<p>In the implementation a source vertex $u$ is chosen to be arbitrary or to be the one of the two odd degree vertices, then an edge $uv$ is marked as visited, then we move to the vertex $v$, next an edge $vw$ is marked as visited, eventually we will get to a vertex $z$ that doesn’t have unvisited edges, this means that there’s a circuit starting at vertex $z$ and ending at vertex $z$, next there might be one vertex $y$ in the circuit $z-z$ that has unvisited edges, if one is found we know that there’s other circuit $y-y$, both circuits $z-z$ and $y-y$ might have nested circuits themselves, when the $y-y$ circuit doesn’t have a vertex with unvisited edges then the result is appended to the main circuit $z-z$ i.e. $u-v-\ldots-z-y-y-z$</p>

<style>
#stack, #trail {
  height: 40px;
}
#figure-find-eulerian-trail span {
  width: 50px;
  border: 1px solid #999;
  padding: 5px 10px;
}
</style>

<div id="figure-find-eulerian-trail">
  <div class="overlay" style="position: absolute"></div>
  <div id="stack">
    stack:
  </div>
  <div id="trail">
    trail:
  </div>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// each edge is saved by id, helper to avoid the traversal
// of an edge many times
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">edge_used</span><span class="p">;</span>
<span class="c1">// the number of edges used in the adjacency list of the vertex `i`
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">edge_pointer</span><span class="p">;</span>
<span class="c1">// the eulerian trail
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">trail</span><span class="p">;</span>
<span class="c1">// the adjacency list representation of `g`, each element `g_{i,j}` is
// a tuple (to, id) which denotes an edge `(i, to)` with id `id`
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">edge_pointer</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">edge_pointer</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">edge</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">edge_pointer</span><span class="p">[</span><span class="n">v</span><span class="p">]];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">edge_used</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// if the edge was already used analyze the next one
</span>      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// mark the edge
</span>    <span class="n">edge_used</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">trail</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
 * Computes an euler trail if possible in an undirected graph `G`
 * whose `edges` are given as an input
 *
 * NOTE: The trail if it exists is saved on the global `trail`
 *
 * @param {int} n The order of the graph
 * @param {vector&lt;pair&lt;int, int&gt; &gt;} A collection of tuples
 * denoting the indexes of the vertices the edge `i` is incident to
 * @return {bool} True if the graph has an euler trail
 */</span>
<span class="n">bool</span> <span class="nf">euler_trail_undirected</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">g</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">());</span>
  <span class="n">edge_pointer</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">edge_used</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">deg</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// build the adjacency list of the graph
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
    <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="p">});</span>
    <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">u</span><span class="p">,</span> <span class="n">i</span> <span class="p">});</span>
    <span class="n">deg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">deg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// find an odd vertex
</span>  <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">odd_degree_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">deg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">odd_degree_count</span><span class="p">;</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">odd_degree_count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">odd_degree_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">trail</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Computes an euler trail if possible in an directed graph `G`
 * whose `edges` are given as an input
 *
 * NOTE: The trail if it exists is saved on the global `trail`
 *
 * @param {int} n The order of the graph
 * @param {vector&lt;pair&lt;int, int&gt; &gt;} A collection of tuples
 * denoting the indexes of the vertices the edge `i` is incident to
 * @return {bool} True if the graph has an euler trail
 */</span>
<span class="n">bool</span> <span class="nf">euler_trail_directed</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">g</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">());</span>
  <span class="n">edge_pointer</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">edge_used</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_deg</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out_deg</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// build the adjacency list of the graph
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
    <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="p">});</span>
    <span class="n">out_deg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">in_deg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// find an odd vertex
</span>  <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">odd_degree_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_deg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_deg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">odd_degree_count</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">out_deg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">in_deg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">odd_degree_count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">odd_degree_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">trail</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<script>
(function () {
  d3.json('/js/graph/data/eulerian-graph.json', function (error, data) {
    greuler({
      target: '#figure-eulerian-graph',
      data: data
    }).update();
  });
  d3.json('/js/graph/data/eulerian-trail.json', function (error, data) {
    greuler({
      target: '#figure-eulerian-trail',
      data: data
    }).update();
  });
  d3.json('/js/graph/data/konigsberg-bridges.json', function (error, data) {
    greuler({
      target: '#figure-konigsberg-bridges',
      data: data
    }).update();
  });

  d3.json('/js/graph/data/eulerian-graph.json', function (error, data) {
    var options = {
      target: '#figure-find-eulerian-trail',
      data: data
    };

    var instance = greuler(options).update();

    // vertices in trail
    var trailEl = d3.select(options.target).append('div');

    var edge_pointer = [];
    var edge_id = {};
    var g = [];
    var n, m;

    var trail = [];
    var stack = [];

    function stackAnimation () {
      var stackSelection = d3.select('#stack').selectAll('span')
        .data(stack)
      stackSelection.enter()
        .append('span')
        .style('opacity', 0)
        .text(function (d) { return d; })
      .transition()
        .style('opacity', 1);
      stackSelection.exit()
        .transition()
        .style('opacity', 0)
        .remove();

      d3.select('#trail').selectAll('span')
        .data(trail)
        .enter()
        .append('span')
        .style('opacity', 0)
        .text(function (d) { return d; })
      .transition()
        .style('opacity', 1);
    }

    function euler () {
      var player = new greuler.player.Generator(instance);
      player.run(function *algorithm(instance) {
        function *eulerianTrail(u) {
          // stack manipulation/animation
          stack.push(u);
          stackAnimation();

          yield function () {
            instance.selector.getNode({ id: u })
              .transition()
              .attr('fill', 'black');
          }

          var edges = instance.graph.getIncidentEdges({ id: u });
          for (var i = 0; i < edges.length; i += 1) {
            var e = edges[i];
            var next = e.target.id === u ? e.source.id : e.target.id;

            if (e.used) { continue; }
            e.used = true;

            yield function () {
              instance.selector.traverseAllEdgesBetween(
                { source: u, target: next },
                { keepStroke: false }
              )
            }

            yield* eulerianTrail(next);
          }

          // stack manipulation/animation
          trail.push(stack.pop());

          yield function () {
            if (trail.length > 1) {
              instance.selector.traverseAllEdgesBetween(
                { source: trail[trail.length - 2], target: trail[trail.length - 1] }
              )
            }
          }

          stackAnimation();

          yield function () {
            instance.selector.getNode({ id: u })
              .transition()
              .attr('fill', '#2980B9');
          }
        }
        yield* eulerianTrail(0);

        // node traversal is given by trail
        // for (var i = 0; i < trail.length; i += 1) {
        //   yield function () {
        //     instance.selector.traverseAllEdgesBetween(
        //       { source: trail[i], target: trail[i + 1] }
        //     );
        //   };
        // }
      });
    }

    var root = d3.select(options.target).node();
    var trackRun = false;
    document.addEventListener('scroll', function (e) {
      var scrollTop = window.scrollY;
      if (!trackRun && scrollTop + window.innerHeight >= root.offsetTop + root.clientHeight) {
        trackRun = true;
        // var el = d3.select('.overlay');
        // var parent = el.node().parentNode;
        // el.style('width', parent.clientWidth + 'px');
        // el.style('height', parent.clientHeight + 'px');
        euler();
        d3.select(options.target)
          .selectAll('svg')
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1)
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1)
          .transition().duration(500).attr('opacity', 0)
          .transition().duration(500).attr('opacity', 1);
      }
    });
  });

})();
</script>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!-- <h2 class="footer-heading">Mauricio Poppe</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Mauricio Poppe</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/maurizzzio">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">maurizzzio</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/iMauricio">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">iMauricio</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Layout run failed ._.
</p>
      </div>
    </div>

  </div>

  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    showProcessingMessages: false,
    messageStyle: 'none',
    tex2jax: {
      // http://docs.mathjax.org/en/latest/options/tex2jax.html
      inlineMath: [['$','$']],
      displayMath: [['$$','$$']]
      // processEnvironments: false
    },
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      },
      Macros: {
        edge: '\\mathrel{-}',
        notedge: '\\not\\edge',
        deg: ['#1^{\\circ}', 1],
        tbold: ['\\textbf{#1}', 1],
        mbold: ['\\mathbf{#1}', 1],
        unit: ['\\widehat{\\mathbf{#1}}', 1],

        magnitude: ['\\left \\| #1 \\right \\|', 1],
        norm: ['\\left \\| #1 \\right \\|', 1]
      }
    },
    'HTML-CSS': {
      imageFont: null
    }
  });
</script>

<script type="text/javascript">
/*
 * MathJax eqn preview for a tags
 *
 * Copyright (c) 2015 Mauricio Poppe
 * Licensed under the MIT license.
 */

(function () {
  var $container = $('.post-content');
  var $tooltip = $('<div />').addClass('mathjax-tooltip');
  $container.append($tooltip);

  function onMouseOver(ev) {
    var a = ev.currentTarget;
    var $number = $(a.hash);
    var $root = $number.closest('.MathJax_Display');
    var bounds = $(a).offset();
    var containerBounds = $container.offset();

    $tooltip.stop(true, true);
    $tooltip.empty();
    $tooltip.append($root.clone());
    $tooltip.css({
      top: bounds.top - containerBounds.top - $tooltip.height() - 5,
      left: -1
    });
    $tooltip.addClass('active');
  }

  function onMouseOut(a) {
    $tooltip.removeClass('active');
  }

  MathJax.Hub.Queue(function () {
    $container.on('mouseover', 'a[href*="mjx-eqn-"]', onMouseOver);
    $container.on('mouseout', 'a[href*="mjx-eqn-"]', onMouseOut);
  });

})();
</script>

</footer>


  </body>

</html>
